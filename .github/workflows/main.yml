name: Build Coccinelle 1.0.7+ (No Docker)

on:
  workflow_dispatch:

permissions:
  contents: write
  
jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Build Coccinelle 1.0.7+ from source
      run: |
        echo "Building Coccinelle 1.0.7+ with compatibility focus"
        
        # 安裝編譯依賴
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          ocaml \
          ocaml-native-compilers \
          ocaml-findlib \
          libpcre3-dev \
          pkg-config \
          python3-dev \
          python3-setuptools \
          autoconf \
          automake \
          libtool \
          m4 \
          wget \
          curl \
          tar
        
        echo "OCaml version: $(ocaml -version)"
        echo "Available OCaml packages:"
        ocamlfind list | head -10
        
        cd /tmp
        SUCCESS_VERSION=""
        
        # 嘗試編譯 1.0.8，失敗則嘗試 1.0.7
        for VERSION in "1.0.8" "1.0.7"; do
            echo "========================================="
            echo "Attempting Coccinelle $VERSION"
            echo "========================================="
            
            rm -rf coccinelle-*
            
            # 下載源碼
            wget https://github.com/coccinelle/coccinelle/archive/refs/tags/$VERSION.tar.gz
            tar -xzf $VERSION.tar.gz
            cd coccinelle-$VERSION
            
            # 生成配置文件
            echo "Running autogen..."
            if [ -f autogen ]; then
                ./autogen
            elif [ -f autogen.sh ]; then
                ./autogen.sh
            else
                autoreconf -fiv
            fi
            
            # 配置 - 使用兼容性設置和舊 GLIBC 目標
            echo "Configuring for GLIBC 2.23 compatibility..."
            if ./configure \
                --prefix=/tmp/coccinelle-install \
                --disable-opt \
                --disable-pcre \
                --enable-python \
                --with-python=python3 \
                CC="gcc -m64" \
                CFLAGS="-O2 -static-libgcc -fno-stack-protector" \
                LDFLAGS="-static-libgcc -Wl,--no-as-needed"; then
                
                echo "✅ Configure successful for $VERSION"
                
                # 編譯
                echo "Building..."
                if make -j$(nproc) 2>&1 | tee build.log; then
                    echo "✅ Build successful for $VERSION!"
                    
                    # 檢查編譯結果
                    if [ -f spatch ]; then
                        echo "Testing spatch..."
                        if ./spatch --version; then
                            echo "✅ spatch test successful!"
                            
                            # 安裝到臨時目錄
                            make install
                            
                            SUCCESS_VERSION="$VERSION"
                            echo "✅ Coccinelle $VERSION installed successfully!"
                            /tmp/coccinelle-install/bin/spatch --version
                            break
                        else
                            echo "❌ spatch test failed"
                        fi
                    else
                        echo "❌ No spatch executable generated"
                        echo "Build log tail:"
                        tail -20 build.log
                    fi
                else
                    echo "❌ Build failed for $VERSION"
                    echo "Build log tail:"
                    tail -20 build.log
                fi
            else
                echo "❌ Configure failed for $VERSION"
            fi
            
            cd /tmp
        done
        
        # 檢查是否有成功的版本
        if [ -z "$SUCCESS_VERSION" ]; then
            echo "❌ All versions failed to build"
            exit 1
        fi
        
        echo "========================================="
        echo "Creating portable package..."
        echo "========================================="
        
        SPATCH_PATH="/tmp/coccinelle-install/bin/spatch"
        
        # 創建可攜式包目錄
        cd /tmp
        rm -rf portable-coccinelle
        mkdir -p portable-coccinelle/{bin,lib,share,python}
        
        # 複製 spatch 二進制
        cp "$SPATCH_PATH" portable-coccinelle/bin/
        echo "✅ Copied spatch binary"
        
        # 複製庫文件
        if [ -d /tmp/coccinelle-install/lib/coccinelle ]; then
            cp -r /tmp/coccinelle-install/lib/coccinelle portable-coccinelle/lib/
            echo "✅ Copied coccinelle libraries"
        fi
        
        # 複製配置文件
        if [ -d /tmp/coccinelle-install/share/coccinelle ]; then
            cp -r /tmp/coccinelle-install/share/coccinelle portable-coccinelle/share/
            echo "✅ Copied coccinelle configuration"
        fi
        
        # 複製系統 OCaml 庫
        for ocaml_dir in /usr/lib/ocaml /usr/lib/x86_64-linux-gnu/ocaml; do
            if [ -d "$ocaml_dir" ]; then
                cp -r "$ocaml_dir" portable-coccinelle/lib/
                echo "✅ Copied OCaml libraries from $ocaml_dir"
                break
            fi
        done
        
        # 複製 Python 模組
        if [ -d /tmp/coccinelle-install/lib/python* ]; then
            cp -r /tmp/coccinelle-install/lib/python*/site-packages/* portable-coccinelle/python/ 2>/dev/null || true
            echo "✅ Copied Python modules"
        fi
        
        # 創建啟動腳本
        cat > portable-coccinelle/spatch.sh << 'LAUNCHER_EOF'
#!/bin/bash
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# 設置環境變數
export LD_LIBRARY_PATH="$SCRIPT_DIR/lib:$SCRIPT_DIR/lib/ocaml:$LD_LIBRARY_PATH"
export OCAML_TOPLEVEL_PATH="$SCRIPT_DIR/lib/ocaml"
export PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$SCRIPT_DIR/lib/coccinelle/python:$SCRIPT_DIR/python"

# 執行 spatch
exec "$SCRIPT_DIR/bin/spatch" "$@"
LAUNCHER_EOF
        
        chmod +x portable-coccinelle/spatch.sh
        chmod +x portable-coccinelle/bin/spatch
        
        # 創建直接可執行的 spatch
        cp portable-coccinelle/spatch.sh portable-coccinelle/spatch
        
        # 創建 README
        FINAL_VERSION=$(/tmp/coccinelle-install/bin/spatch --version | head -1)
        cat > portable-coccinelle/README.md << 'README_EOF'
# Portable Coccinelle for Ubuntu 16.04+

## Version Information
Built from source on Ubuntu 22.04 with GLIBC 2.23+ compatibility

## Usage
```bash
./spatch.sh --version
./spatch --version
```

## Installation
```bash
tar -xzf coccinelle-portable.tar.gz
cd portable-coccinelle
./spatch --version
```

## Compatibility
- Target: Ubuntu 16.04+ (GLIBC 2.23+)
- Python 3 support
- OCaml runtime included
- Static-linked where possible
README_EOF
        
        # 測試可攜式版本
        echo "Testing portable version..."
        ./portable-coccinelle/spatch.sh --version
        
        # 檢查依賴
        echo "Binary dependencies:"
        ldd portable-coccinelle/bin/spatch | head -10
        
        # 打包
        PACKAGE_FILE="coccinelle-${SUCCESS_VERSION}-portable.tar.gz"
        tar -czf "$PACKAGE_FILE" portable-coccinelle/
        
        echo "✅ Package created: $PACKAGE_FILE"
        echo "Package size: $(du -h $PACKAGE_FILE | cut -f1)"
        
        # 移動到工作目錄
        mv "$PACKAGE_FILE" /home/runner/work/coccinelle-build/coccinelle-build/
        
        echo "========================================="
        echo "Creating GitHub Release..."
        echo "========================================="
        
        cd /home/runner/work/coccinelle-build/coccinelle-build/
        
        RELEASE_TAG="coccinelle-${SUCCESS_VERSION}-$(date +%Y%m%d-%H%M%S)"
        RELEASE_NAME="Coccinelle ${SUCCESS_VERSION} (Source Build)"
        
        # 創建 JSON payload
        cat > payload.json << 'JSON_EOF'
{
  "tag_name": "REPLACE_TAG",
  "target_commitish": "main",
  "name": "REPLACE_NAME", 
  "body": "REPLACE_BODY",
  "draft": false,
  "prerelease": false
}
JSON_EOF
        
        # 替換佔位符
        sed -i "s/REPLACE_TAG/$RELEASE_TAG/" payload.json
        sed -i "s/REPLACE_NAME/$RELEASE_NAME/" payload.json
        sed -i "s/REPLACE_BODY/Coccinelle $SUCCESS_VERSION built from source with GLIBC 2.23+ compatibility/" payload.json
        
        # 創建 release
        RELEASE_RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}" -X POST \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Content-Type: application/json" \
          "https://api.github.com/repos/$GITHUB_REPOSITORY/releases" \
          -d @payload.json)
        
        HTTP_CODE=$(echo "$RELEASE_RESPONSE" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
        RESPONSE_BODY=$(echo "$RELEASE_RESPONSE" | sed 's/HTTP_CODE:[0-9]*$//')
        
        if [ "$HTTP_CODE" = "201" ]; then
            UPLOAD_URL=$(echo "$RESPONSE_BODY" | grep -o '"upload_url": "[^"]*' | cut -d'"' -f4 | sed 's/{?name,label}//')
            RELEASE_HTML_URL=$(echo "$RESPONSE_BODY" | grep -o '"html_url": "[^"]*' | cut -d'"' -f4)
            
            echo "✅ Release created: $RELEASE_HTML_URL"
            echo "Uploading package..."
            
            UPLOAD_RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}" -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: application/gzip" \
              --data-binary "@$PACKAGE_FILE" \
              "${UPLOAD_URL}?name=$PACKAGE_FILE")
            
            UPLOAD_HTTP_CODE=$(echo "$UPLOAD_RESPONSE" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
            
            if [ "$UPLOAD_HTTP_CODE" = "201" ]; then
                echo "========================================="
                echo "🎉 SUCCESS! Coccinelle $SUCCESS_VERSION"
                echo "========================================="
                echo "Release: $RELEASE_HTML_URL"
                echo "Package: $PACKAGE_FILE"  
                echo "Version: $FINAL_VERSION"
                echo "========================================="
            else
                echo "❌ Upload failed (HTTP $UPLOAD_HTTP_CODE)"
            fi
        else
            echo "❌ Release creation failed (HTTP $HTTP_CODE)"
            echo "Response: $RESPONSE_BODY"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
