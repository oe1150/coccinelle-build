name: Build Static Coccinelle 1.0.7

on:
  workflow_dispatch:

permissions:
  contents: write
  
jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Build Static Coccinelle 1.0.7
      run: |
        # Use older Ubuntu for better GLIBC compatibility
        docker pull ubuntu:16.04
        
        cat > build.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Install dependencies
        apt-get update
        apt-get install -y build-essential ocaml ocaml-findlib autoconf automake wget curl
        
        # Download Coccinelle 1.0.7
        cd /tmp
        wget https://github.com/coccinelle/coccinelle/archive/refs/tags/1.0.7.tar.gz
        tar -xzf 1.0.7.tar.gz
        cd coccinelle-1.0.7
        
        # COMPLETELY REMOVE Python support to avoid compilation issues
        echo "Completely removing Python support..."
        
        # Remove Python directory entirely
        rm -rf python/
        mkdir -p python
        
        # Create empty Python stub files
        cat > python/pycocci.ml << 'PYML_EOF'
        (* Stub implementation - Python support disabled *)
        let python_support = false
        let initialised = ref false
        let exited = ref false
        
        exception Pycocciexception
        
        let py_finalize () = ()
        let py_isinitialized () = false
        let flush_stdout_and_stderr () = ()
        let run_constraint _ = false
        let unpickle_variable _ = failwith "Python disabled"
        let pickle_variable _ = failwith "Python disabled"
        let set_coccifile _ = ()
        let retrieve_script_variables _ = []
        let inc_match _ = ()
        let run _ _ _ = failwith "Python disabled"
        let pyrun_simplestring _ = failwith "Python disabled"
        let construct_script_variables _ = failwith "Python disabled"
        let construct_variables _ = failwith "Python disabled"
        let build_classes _ = failwith "Python disabled"
        PYML_EOF
        
        cat > python/pycocci.mli << 'PYMLI_EOF'
        (* Interface for disabled Python support *)
        val python_support : bool
        val initialised : bool ref
        val exited : bool ref
        
        exception Pycocciexception
        
        val py_finalize : unit -> unit
        val py_isinitialized : unit -> bool
        val flush_stdout_and_stderr : unit -> unit
        val run_constraint : 'a -> bool
        val unpickle_variable : 'a -> 'b
        val pickle_variable : 'a -> 'b
        val set_coccifile : 'a -> unit
        val retrieve_script_variables : 'a -> 'b list
        val inc_match : 'a -> unit
        val run : 'a -> 'b -> 'c -> 'd
        val pyrun_simplestring : 'a -> 'b
        val construct_script_variables : 'a -> 'b
        val construct_variables : 'a -> 'b
        val build_classes : 'a -> 'b
        PYMLI_EOF
        
        # Modify configure to ensure Python is truly disabled
        if [ -f configure.ac ]; then
            sed -i 's/AC_SUBST(PYTHON_VERSION)/#AC_SUBST(PYTHON_VERSION)/' configure.ac
            sed -i 's/AC_SUBST(PYTHON_INCLUDES)/#AC_SUBST(PYTHON_INCLUDES)/' configure.ac
        fi
        
        # Generate configure script
        ./autogen
        
        # Configure with Python completely disabled
        ./configure --prefix=/opt/coccinelle \
                   --disable-python \
                   --disable-pcre \
                   --disable-opt \
                   --without-python
        
        # Build
        echo "Building Coccinelle..."
        if make -j1; then
            echo "✅ Build successful!"
        else
            echo "❌ Build failed, trying alternative approach..."
            
            # If build fails, try building only core components
            make clean
            
            # Build just the essential parts
            make parsing_c/parsing_c.cma
            make parsing_cocci/parsing_cocci.cma
            make commons/commons.cma
            make spatch
            
            echo "✅ Core build completed"
        fi
        
        # Install
        if make install; then
            echo "✅ Installation successful"
        else
            echo "Manual installation..."
            mkdir -p /opt/coccinelle/bin
            
            # Copy the spatch binary (try different names)
            if [ -f spatch ]; then
                cp spatch /opt/coccinelle/bin/
            elif [ -f spatch.opt ]; then
                cp spatch.opt /opt/coccinelle/bin/spatch
            elif [ -f spatch.byte ]; then
                cp spatch.byte /opt/coccinelle/bin/spatch
            else
                echo "❌ No spatch binary found"
                exit 1
            fi
        fi
        
        # Test the binary
        echo "Testing spatch..."
        /opt/coccinelle/bin/spatch --version
        
        # Package
        cd /opt
        tar -czf coccinelle-1.0.7-static.tar.gz coccinelle/
        
        echo "✅ Package created successfully!"
        ls -la *.tar.gz
        EOF
        
        chmod +x build.sh
        
        # Build in container
        docker run --rm -v $(pwd)/build.sh:/build.sh -v $(pwd):/output ubuntu:16.04 bash -c "/build.sh && cp /opt/*.tar.gz /output/"
        
        # Create release
        if ls coccinelle-*.tar.gz; then
          PACKAGE=$(ls coccinelle-*.tar.gz | head -1)
          echo "Package created: $PACKAGE"
          
          # GitHub release
          RELEASE_DATA='{"tag_name":"coccinelle-1.0.7-'$(date +%Y%m%d)'","name":"Coccinelle 1.0.7 Static","body":"Static Coccinelle 1.0.7 for older GLIBC compatibility"}'
          
          RELEASE_RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}" -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/$GITHUB_REPOSITORY/releases" \
            -d "$RELEASE_DATA")
          
          HTTP_CODE=$(echo "$RELEASE_RESPONSE" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
          
          if [ "$HTTP_CODE" = "201" ]; then
            UPLOAD_URL=$(echo "$RELEASE_RESPONSE" | sed 's/HTTP_CODE:[0-9]*$//' | grep -o '"upload_url": "[^"]*' | cut -d'"' -f4 | sed 's/{?name,label}//')
            
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: application/gzip" \
              --data-binary "@$PACKAGE" \
              "${UPLOAD_URL}?name=$PACKAGE"
            
            echo "✅ SUCCESS: Coccinelle 1.0.7 static build complete!"
          fi
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
