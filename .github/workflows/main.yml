name: Build Static Coccinelle for Ubuntu 16

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: write
  
jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Build Static Coccinelle 1.0.8 for Ubuntu 16
      run: |
        echo "ðŸš€ Building Coccinelle 1.0.8 for Ubuntu 16 compatibility..."
        
        # Create build script
        cat > build_coccinelle.sh << 'BUILDEOF'
        #!/bin/bash
        set -ex
        
        echo "ðŸ” Checking GLIBC version..."
        ldd --version
        echo "Target: Ubuntu 16.04 (GLIBC 2.23)"
        
        echo "ðŸ“¦ Installing build dependencies..."
        apt-get update
        apt-get install -y build-essential ocaml ocaml-native-compilers ocaml-findlib camlp4 libpcre3-dev pkg-config autoconf automake libtool m4 wget curl python-dev python3-dev tcsh csh || true
        
        echo "ðŸ“¥ Downloading Coccinelle 1.0.8..."
        cd /tmp
        wget -O coccinelle-1.0.8.tar.gz https://github.com/coccinelle/coccinelle/archive/refs/tags/1.0.8.tar.gz
        tar -xzf coccinelle-1.0.8.tar.gz
        cd coccinelle-1.0.8
        
        echo "ðŸ”§ Preparing Python stub files..."
        mkdir -p python
        
        echo "Creating comprehensive Python stubs..."
        
        # åˆ›å»º no_pycocci.mli
        cat > python/no_pycocci.mli << 'ENDMLI'
val python_support : bool
val initialised : bool ref  
val exited : bool ref
exception Pycocciexception
val py_finalize : unit -> unit
val py_isinitialized : unit -> bool
val flush_stdout_and_stderr : unit -> unit
val run_constraint : 'a -> bool
val inc_match : unit -> unit
val run : string -> unit
val pyrun_simplestring : string -> unit
val retrieve_script_variables : unit -> 'a list
val set_coccifile : string -> unit
val unpickle_variable : string -> 'a
val pickle_variable : 'a -> string
val construct_script_variables : 'a list -> unit
val construct_variables : string list -> unit
val build_classes : 'a list -> unit
ENDMLI

        # åˆ›å»º no_pycocci.ml
        cat > python/no_pycocci.ml << 'ENDML'  
let python_support = false
let initialised = ref false
let exited = ref false
exception Pycocciexception
let py_finalize () = ()
let py_isinitialized () = false
let flush_stdout_and_stderr () = ()
let run_constraint _ = false
let inc_match () = ()
let run _ = ()
let pyrun_simplestring _ = ()
let retrieve_script_variables () = []
let set_coccifile _ = ()
let unpickle_variable _ = failwith "Python support disabled"
let pickle_variable _ = failwith "Python support disabled"
let construct_script_variables _ = ()
let construct_variables _ = ()
let build_classes _ = ()
ENDML

        # åˆ›å»º pycocci.mli (å¯èƒ½è¢«æŸäº›ç‰ˆæœ¬éœ€è¦)
        cp python/no_pycocci.mli python/pycocci.mli
        cp python/no_pycocci.ml python/pycocci.ml
        
        # åˆ›å»º pycocci_aux æ–‡ä»¶
        cat > python/pycocci_aux.mli << 'ENDAUXMLI'
val check_return_value : 'a -> unit
val convert_list : ('a -> 'b) -> 'a list -> 'b  
val pystring_fromstring : string -> 'a
val pystring_asstring : 'a -> string
ENDAUXMLI

        cat > python/pycocci_aux.ml << 'ENDAUXML'
let check_return_value _ = ()
let convert_list _ _ = failwith "Python disabled"
let pystring_fromstring _ = failwith "Python disabled" 
let pystring_asstring _ = failwith "Python disabled"
ENDAUXML

        # åˆ›å»ºç©ºçš„ Makefile
        cat > python/Makefile << 'ENDMAKE'
SOURCES = no_pycocci.ml pycocci.ml pycocci_aux.ml
INTERFACES = no_pycocci.mli pycocci.mli pycocci_aux.mli

all: $(SOURCES:.ml=.cmo) $(INTERFACES:.mli=.cmi)

%.cmi: %.mli
	@echo "Compiling interface $<"
	ocamlc -c $<

%.cmo: %.ml %.cmi
	@echo "Compiling implementation $<"  
	ocamlc -c $<

clean:
	rm -f *.cmi *.cmo *.cmx *.o

install:
	@echo "Python support disabled"

.PHONY: all clean install
ENDMAKE

        # åˆ›å»ºä¾èµ–æ–‡ä»¶
        cat > python/.depend << 'ENDDEP'
no_pycocci.cmi: no_pycocci.mli
no_pycocci.cmo: no_pycocci.ml no_pycocci.cmi
pycocci.cmi: pycocci.mli  
pycocci.cmo: pycocci.ml pycocci.cmi
pycocci_aux.cmi: pycocci_aux.mli
pycocci_aux.cmo: pycocci_aux.ml pycocci_aux.cmi
ENDDEP
        
        echo "ðŸ”§ Configuring build..."
        if [ -f autogen ]; then
            ./autogen
        elif [ -f autogen.sh ]; then
            ./autogen.sh
        else
            autoreconf -fiv
        fi
        
        export CFLAGS="-static-libgcc -O2 -fPIC"
        export LDFLAGS="-static-libgcc -Wl,--as-needed"
        
        # ä¿®æ”¹ Makefile ä»¥ç§»é™¤ python ç›®å½•å¼•ç”¨
        echo "ðŸ”§ Patching Makefile to remove python references..."
        if [ -f Makefile.in ]; then
            sed -i 's/-I python//g' Makefile.in
            sed -i 's/python//g' Makefile.in
        fi
        
        ./configure --prefix=/opt/coccinelle --disable-python --disable-pcre --disable-opt --enable-release --without-python --without-pycaml CC="gcc" CXX="g++" PYTHON="no" PYCAML="no"
        
        # åœ¨configureåŽå†æ¬¡ä¿®æ”¹ç”Ÿæˆçš„Makefile
        if [ -f Makefile ]; then
            echo "ðŸ”§ Patching generated Makefile..."
            sed -i 's/-I python//g' Makefile
            sed -i 's/python\/[^ ]* //g' Makefile
            sed -i 's/python\/[^ ]*\.cmo//g' Makefile
            sed -i 's/python\/[^ ]*\.cmx//g' Makefile
        fi
        
        # ä¿®æ”¹æ‰€æœ‰å¯èƒ½åŒ…å«pythonå¼•ç”¨çš„æ–‡ä»¶
        find . -name "*.mk" -o -name "Makefile*" | xargs sed -i 's/-I python//g' 2>/dev/null || true
        find . -name "*.mk" -o -name "Makefile*" | xargs sed -i 's/python\/[^ ]* //g' 2>/dev/null || true
        
        echo "ðŸ”¨ Building Coccinelle..."
        make clean || true
        
        # ç¡®ä¿pythonç›®å½•å­˜åœ¨ä½†å†…å®¹æœ€å°åŒ–
        if [ ! -d python ]; then
            mkdir -p python
            echo "# Dummy python module" > python/dummy.ml
            echo "# Dummy python interface" > python/dummy.mli
            touch python/.depend
            echo "all:" > python/Makefile
            echo -e "\t@echo 'Python disabled'" >> python/Makefile
        fi
        
        # ç”Ÿæˆä¾èµ–ï¼Œä½†å¿½ç•¥pythonç›¸å…³é”™è¯¯
        echo "ðŸ“‹ Generating dependencies..."
        make depend 2>&1 | grep -v "Bad -I option: python" || true
        
        BUILD_SUCCESS=false
        
        echo "ðŸ”„ Trying standard build..."
        if make world -j1 2>&1 | grep -v "Bad -I option: python"; then
            echo "âœ… Standard build successful!"
            BUILD_SUCCESS=true
        else
            echo "âŒ Standard build failed, trying alternative approach..."
            
            # å®Œå…¨ç¦ç”¨pythonæ¨¡å—
            echo "ðŸ”„ Completely disabling python module..."
            if [ -d python ]; then
                # ä¿ç•™ç›®å½•ä½†æ¸…ç©ºå†…å®¹ï¼Œåªä¿ç•™æœ€åŸºæœ¬çš„æ–‡ä»¶
                rm -rf python/*
                
                # åˆ›å»ºæœ€å°çš„å­˜æ ¹æ–‡ä»¶
                echo "(* Empty python module *)" > python/no_pycocci.ml
                echo "(* Empty python interface *)" > python/no_pycocci.mli
                echo "all:" > python/Makefile
                echo -e "\t@true" >> python/Makefile
                echo ".PHONY: all clean install" >> python/Makefile
                echo "clean:" >> python/Makefile
                echo -e "\t@true" >> python/Makefile
                echo "install:" >> python/Makefile
                echo -e "\t@true" >> python/Makefile
                touch python/.depend
            fi
            
            # ä¿®æ”¹ä¸»Makefileä»¥è·³è¿‡pythonç¼–è¯‘
            if [ -f Makefile ]; then
                echo "ðŸ”§ Modifying Makefile to skip python compilation..."
                # æ›¿æ¢pythonç›¸å…³çš„ç›®æ ‡
                sed -i 's/python\.cma//g' Makefile
                sed -i 's/python\.cmxa//g' Makefile
                sed -i 's/PYTHON_MODULES[^=]*=[^;]*/PYTHON_MODULES=/g' Makefile
                sed -i '/^.*python\/.*\.cm[oxa]/d' Makefile
            fi
            
            make clean
            if make world -j1 2>&1 | grep -v "Bad -I option: python"; then
                echo "âœ… Build without python compilation successful!"
                BUILD_SUCCESS=true
            else
                echo "âŒ World build failed, trying core components..."
                make clean
                
                # å°è¯•åªæž„å»ºæ ¸å¿ƒç»„ä»¶
                echo "ðŸ”„ Building core components only..."
                for component in commons parsing_c parsing_cocci ctl engine popl09 extra; do
                    if [ -d "$component" ]; then
                        echo "Building $component..."
                        (cd "$component" && make all) 2>&1 | grep -v "Bad -I option: python" || echo "Warning: $component had issues"
                    fi
                done
                
                # å°è¯•æž„å»ºä¸»ç¨‹åº
                if make spatch 2>&1 | grep -v "Bad -I option: python"; then
                    echo "âœ… Core build successful!"
                    BUILD_SUCCESS=true
                fi
            fi
        fi
        
        if [ "$BUILD_SUCCESS" = "false" ]; then
            echo "âŒ All build attempts failed"
            echo "ðŸ” Final diagnostics..."
            echo "=== Makefile python references ==="
            grep -n python Makefile || echo "No python references in Makefile"
            echo "=== Python directory contents ==="
            ls -la python/ || echo "No python directory"
            exit 1
        fi
        
        echo "ðŸ“¦ Installing..."
        if make install; then
            echo "âœ… Installation successful!"
        else
            echo "âš ï¸ Standard install failed, trying manual install..."
            mkdir -p /opt/coccinelle/bin
            mkdir -p /opt/coccinelle/share/coccinelle
            
            SPATCH_FOUND=false
            for spatch_name in spatch spatch.byte spatch.opt main.byte main.opt; do
                if [ -f "$spatch_name" ]; then
                    echo "Found spatch binary: $spatch_name"
                    cp "$spatch_name" /opt/coccinelle/bin/spatch
                    chmod +x /opt/coccinelle/bin/spatch
                    SPATCH_FOUND=true
                    break
                fi
            done
            
            if [ "$SPATCH_FOUND" = "false" ]; then
                SPATCH_PATH=$(find . -name "*spatch*" -type f -executable | head -1)
                if [ -n "$SPATCH_PATH" ]; then
                    cp "$SPATCH_PATH" /opt/coccinelle/bin/spatch
                    chmod +x /opt/coccinelle/bin/spatch
                    SPATCH_FOUND=true
                fi
            fi
            
            if [ "$SPATCH_FOUND" = "false" ]; then
                echo "âŒ Cannot find any spatch binary!"
                exit 1
            fi
        fi
        
        # æ£€æŸ¥spatchæ˜¯å¦ä¸ºè„šæœ¬ï¼Œå¦‚æžœæ˜¯åˆ™ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„è§£é‡Šå™¨
        echo "ðŸ”§ Checking spatch binary type..."
        if [ -f /opt/coccinelle/bin/spatch ]; then
            file /opt/coccinelle/bin/spatch
            
            # å¦‚æžœæ˜¯tcshè„šæœ¬ï¼Œåˆ›å»ºbashåŒ…è£…å™¨
            if head -1 /opt/coccinelle/bin/spatch | grep -q tcsh; then
                echo "Detected tcsh script, creating bash wrapper..."
                mv /opt/coccinelle/bin/spatch /opt/coccinelle/bin/spatch.tcsh
                cat > /opt/coccinelle/bin/spatch << 'WRAPPEREOF'
#!/bin/bash
# Bash wrapper for spatch tcsh script
SCRIPT_DIR="$(dirname "$0")"
export PATH="/bin:/usr/bin:$PATH"
if command -v tcsh >/dev/null 2>&1; then
    exec tcsh "$SCRIPT_DIR/spatch.tcsh" "$@"
elif command -v csh >/dev/null 2>&1; then
    exec csh "$SCRIPT_DIR/spatch.tcsh" "$@"
else
    echo "Error: tcsh or csh is required to run spatch" >&2
    exit 1
fi
WRAPPEREOF
                chmod +x /opt/coccinelle/bin/spatch
                echo "Created bash wrapper for tcsh script"
            fi
        fi
        
        echo "âœ… Testing installation..."
        if [ ! -f /opt/coccinelle/bin/spatch ]; then
            echo "âŒ spatch binary not found after installation!"
            exit 1
        fi
        
        echo "ðŸ“‹ Binary dependencies:"
        ldd /opt/coccinelle/bin/spatch || echo "Static binary (no dynamic dependencies - GOOD!)"
        
        echo "ðŸ§ª Testing spatch functionality..."
        if /opt/coccinelle/bin/spatch --version; then
            echo "âœ… Version check successful"
        elif /opt/coccinelle/bin/spatch -version; then
            echo "âœ… Version check successful (alternative flag)"
        elif /opt/coccinelle/bin/spatch --help | head -5; then
            echo "âœ… Help output available"
        else
            echo "âš ï¸ Testing basic functionality..."
            if /opt/coccinelle/bin/spatch 2>&1 | grep -i "coccinelle\|spatch\|usage" >/dev/null; then
                echo "âœ… Binary appears functional"
            else
                echo "âŒ Binary test failed"
                exit 1
            fi
        fi
        
        echo "ðŸ” Compatibility check..."
        echo "Built on GLIBC: $(ldd --version | head -1)"
        
        echo "ðŸ“¦ Creating portable package..."
        cd /opt
        tar -czf coccinelle-1.0.8-ubuntu16-static.tar.gz coccinelle/
        
        echo "âœ… Package created successfully!"
        ls -la *.tar.gz
        cp *.tar.gz /output/
        BUILDEOF
        
        chmod +x build_coccinelle.sh
        
        echo "ðŸ³ Starting Docker build..."
        docker run --rm -v $(pwd)/build_coccinelle.sh:/build_coccinelle.sh -v $(pwd):/output ubuntu:16.04 bash -c "/build_coccinelle.sh"
    
    - name: Verify build
      run: |
        if ls coccinelle-*.tar.gz 1> /dev/null 2>&1; then
          PACKAGE=$(ls coccinelle-*.tar.gz | head -1)
          echo "âœ… Package created: $PACKAGE"
          echo "ðŸ“Š Package size: $(du -h $PACKAGE | cut -f1)"
          
          mkdir -p test_extract
          tar -xzf $PACKAGE -C test_extract
          
          if [ -f test_extract/coccinelle/bin/spatch ]; then
            echo "âœ… spatch binary found in package"
            
            echo "ðŸ§ª Testing GLIBC compatibility with Ubuntu 16..."
            docker run --rm -v $(pwd)/test_extract:/test ubuntu:16.04 bash -c "
              # Install tcsh which is needed by spatch
              apt-get update && apt-get install -y tcsh csh
              
              echo 'Ubuntu 16.04 GLIBC version:'
              ldd --version
              echo 'Testing spatch binary:'
              
              # Check if it's a script or binary
              file /test/coccinelle/bin/spatch
              
              # Check shebang if it's a script
              head -1 /test/coccinelle/bin/spatch
              
              # Try to run it
              if /test/coccinelle/bin/spatch --version 2>&1; then
                echo 'âœ… SUCCESS: Binary works on Ubuntu 16.04!'
              elif /test/coccinelle/bin/spatch -version 2>&1; then
                echo 'âœ… SUCCESS: Binary works with -version flag!'
              else
                echo 'âŒ Testing with alternative methods...'
                echo 'Binary type:'
                file /test/coccinelle/bin/spatch
                echo 'Dependencies:'
                ldd /test/coccinelle/bin/spatch 2>&1 || echo 'Static or script'
                echo 'First few lines:'
                head -5 /test/coccinelle/bin/spatch
                
                # If it's a script, try to fix the shebang
                if head -1 /test/coccinelle/bin/spatch | grep -q tcsh; then
                  echo 'Detected tcsh script, creating bash wrapper...'
                  mv /test/coccinelle/bin/spatch /test/coccinelle/bin/spatch.tcsh
                  cat > /test/coccinelle/bin/spatch << 'WRAPPER'
#!/bin/bash
# Wrapper for spatch tcsh script
export PATH=\"/bin:/usr/bin:\$PATH\"
exec tcsh /test/coccinelle/bin/spatch.tcsh \"\$@\"
WRAPPER
                  chmod +x /test/coccinelle/bin/spatch
                  
                  # Test the wrapper
                  if /test/coccinelle/bin/spatch --version; then
                    echo 'âœ… SUCCESS: Wrapper works!'
                  else
                    echo 'âŒ Wrapper also failed'
                    exit 1
                  fi
                else
                  echo 'âŒ FAILED: Binary incompatible with Ubuntu 16.04'
                  exit 1
                fi
              fi
            "
            
            echo "PACKAGE_NAME=$PACKAGE" >> $GITHUB_ENV
          else
            echo "âŒ spatch binary not found in package"
            exit 1
          fi
        else
          echo "âŒ No package file found"
          exit 1
        fi
    
    - name: Create Release
      if: github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: coccinelle-1.0.8-${{ github.run_number }}
        name: "Coccinelle 1.0.8 for Ubuntu 16 (Build ${{ github.run_number }})"
        body: |
          # Coccinelle 1.0.8 Static Build for Ubuntu 16
          
          **âœ… GLIBC Compatibility Verified**: This build has been tested on Ubuntu 16.04 (GLIBC 2.23)
          
          This is a statically compiled version of Coccinelle 1.0.8 that is compatible with Ubuntu 16.04 and older GLIBC versions. It solves the `GLIBC_2.29' not found` error.
          
          ## ðŸš€ Quick Installation for QSDK
          
          ```bash
          # Download and extract (replace URL with actual release URL)
          cd /home/cassie_xiao
          wget https://github.com/${{ github.repository }}/releases/latest/download/coccinelle-1.0.8-ubuntu16-static.tar.gz
          tar -xzf coccinelle-1.0.8-ubuntu16-static.tar.gz
          
          # Set up environment
          export PATH="/home/cassie_xiao/coccinelle/bin:$PATH"
          echo 'export PATH="/home/cassie_xiao/coccinelle/bin:$PATH"' >> ~/.bashrc
          
          # Verify installation
          spatch --version
          # Should show version >= 1.0.8
          
          # Test QSDK build
          cd /home/cassie_xiao/20250612/qsdk
          make package/feeds/wlan_open/mac80211/compile
          ```
          
          ## ðŸ”§ Technical Details
          
          - **Built on**: Ubuntu 16.04 (GLIBC 2.23)
          - **Target**: Ubuntu 16.04+ systems
          - **Static linking**: Minimized GLIBC dependencies
          - **Version**: 1.0.8 (satisfies >= 1.0.7 requirement)
          
          ## â“ Troubleshooting
          
          If you still encounter GLIBC errors:
          
          1. **Check your system GLIBC**:
             ```bash
             ldd --version
             ```
          
          2. **Verify spatch dependencies**:
             ```bash
             ldd /home/cassie_xiao/coccinelle/bin/spatch
             ```
          
          3. **Alternative path setup**:
             ```bash
             # Add to your shell profile
             echo 'export PATH="/home/cassie_xiao/coccinelle/bin:$PATH"' >> ~/.profile
             source ~/.profile
             ```
          
          Built on: ${{ github.run_date }}  
          Commit: ${{ github.sha }}
          
          **Compatibility tested**: âœ… Ubuntu 16.04
        files: |
          coccinelle-*-static.tar.gz
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: coccinelle-ubuntu16-compatible
        path: coccinelle-*.tar.gz
        retention-days: 30
