name: Build Coccinelle 1.0.7+ (GLIBC 2.23 Compatible)

on:
  workflow_dispatch:

permissions:
  contents: write
  
jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Build Coccinelle 1.0.7+ with GLIBC 2.23 compatibility
      run: |
        echo "========================================="
        echo "Building Coccinelle 1.0.7+ for GLIBC 2.23"
        echo "========================================="
        
        # å®‰è£ä¾è³´
        apt-get update -qq
        apt-get install -y -qq \
          build-essential \
          wget curl tar ca-certificates \
          docker.io
        
        # å•Ÿå‹• Docker æœå‹™
        service docker start
        
        # ä½¿ç”¨ Docker åœ¨ Ubuntu 16.04 ç’°å¢ƒä¸­ç·¨è­¯
        cat > Dockerfile << 'DOCKERFILE'
FROM ubuntu:16.04

# å®‰è£ç·¨è­¯ä¾è³´
RUN apt-get update && apt-get install -y \
    build-essential \
    ocaml \
    ocaml-native-compilers \
    ocaml-findlib \
    libpcre3-dev \
    pkg-config \
    python3-dev \
    python3-setuptools \
    wget \
    curl \
    tar \
    ca-certificates \
    autoconf \
    automake \
    libtool \
    m4 \
    git

WORKDIR /build

# ç·¨è­¯è…³æœ¬
COPY build_script.sh /build/
RUN chmod +x /build/build_script.sh
RUN ./build_script.sh

# å‰µå»ºå¯æ”œå¼åŒ…
COPY package_script.sh /build/
RUN chmod +x /build/package_script.sh
RUN ./package_script.sh
DOCKERFILE

        # å‰µå»ºç·¨è­¯è…³æœ¬
        cat > build_script.sh << 'BUILDSCRIPT'
#!/bin/bash
set -e

echo "Building Coccinelle 1.0.7+ from source..."

# å˜—è©¦ç·¨è­¯ 1.0.8ï¼Œå¤±æ•—å‰‡å˜—è©¦ 1.0.7
for VERSION in "1.0.8" "1.0.7"; do
    echo "========================================="
    echo "Attempting Coccinelle $VERSION"
    echo "========================================="
    
    cd /build
    rm -rf coccinelle-*
    
    # ä¸‹è¼‰æºç¢¼
    wget https://github.com/coccinelle/coccinelle/archive/refs/tags/$VERSION.tar.gz
    tar -xzf $VERSION.tar.gz
    cd coccinelle-$VERSION
    
    echo "OCaml version: $(ocaml -version)"
    echo "Available OCaml packages:"
    ocamlfind list | grep -E "(unix|str|pcre)" || echo "Some packages missing"
    
    # ç”Ÿæˆé…ç½®æ–‡ä»¶
    echo "Running autogen..."
    if [ -f autogen ]; then
        ./autogen
    elif [ -f autogen.sh ]; then
        ./autogen.sh
    else
        autoreconf -fiv
    fi
    
    # é…ç½® - é‡å°å…¼å®¹æ€§
    echo "Configuring..."
    if ./configure \
        --prefix=/usr/local \
        --disable-opt \
        --disable-pcre \
        --enable-python \
        --with-python=python3 \
        CFLAGS="-O2 -g" \
        LDFLAGS="-Wl,--no-as-needed"; then
        
        echo "âœ… Configure successful for $VERSION"
        
        # ç·¨è­¯
        echo "Building..."
        if make -j$(nproc); then
            echo "âœ… Build successful for $VERSION!"
            
            # æª¢æŸ¥ç·¨è­¯çµæžœ
            if [ -f spatch ]; then
                echo "Testing spatch..."
                ./spatch --version
                
                # å®‰è£
                make install
                
                echo "âœ… Coccinelle $VERSION installed successfully!"
                /usr/local/bin/spatch --version
                
                # è¨˜éŒ„æˆåŠŸç‰ˆæœ¬
                echo "$VERSION" > /build/SUCCESS_VERSION
                break
            else
                echo "âŒ No spatch executable generated for $VERSION"
            fi
        else
            echo "âŒ Build failed for $VERSION"
        fi
    else
        echo "âŒ Configure failed for $VERSION"
    fi
done

# æª¢æŸ¥æ˜¯å¦æœ‰æˆåŠŸçš„ç‰ˆæœ¬
if [ ! -f /build/SUCCESS_VERSION ]; then
    echo "âŒ All versions failed to build"
    exit 1
fi

echo "âœ… Successfully built Coccinelle $(cat /build/SUCCESS_VERSION)"
BUILDSCRIPT

        # å‰µå»ºæ‰“åŒ…è…³æœ¬
        cat > package_script.sh << 'PACKAGESCRIPT'
#!/bin/bash
set -e

echo "Creating portable package..."

SUCCESS_VERSION=$(cat /build/SUCCESS_VERSION)
SPATCH_PATH="/usr/local/bin/spatch"

# æª¢æŸ¥å®‰è£çš„ç‰ˆæœ¬
echo "Installed version: $($SPATCH_PATH --version | head -1)"

# å‰µå»ºå¯æ”œå¼åŒ…ç›®éŒ„
cd /build
rm -rf portable-coccinelle
mkdir -p portable-coccinelle/{bin,lib,share,python}

# è¤‡è£½ spatch äºŒé€²åˆ¶
cp "$SPATCH_PATH" portable-coccinelle/bin/

# è¤‡è£½åº«æ–‡ä»¶
if [ -d /usr/local/lib/coccinelle ]; then
    cp -r /usr/local/lib/coccinelle portable-coccinelle/lib/
    echo "âœ… Copied coccinelle libraries"
fi

# è¤‡è£½é…ç½®æ–‡ä»¶
if [ -d /usr/local/share/coccinelle ]; then
    cp -r /usr/local/share/coccinelle portable-coccinelle/share/
    echo "âœ… Copied coccinelle configuration"
fi

# è¤‡è£½ OCaml åº«
for ocaml_dir in /usr/lib/ocaml /usr/lib/x86_64-linux-gnu/ocaml; do
    if [ -d "$ocaml_dir" ]; then
        cp -r "$ocaml_dir" portable-coccinelle/lib/
        echo "âœ… Copied OCaml libraries from $ocaml_dir"
        break
    fi
done

# è¤‡è£½ Python æ¨¡çµ„
if [ -d /usr/local/lib/python*/site-packages ]; then
    cp -r /usr/local/lib/python*/site-packages/coccinelle portable-coccinelle/python/ 2>/dev/null || true
    echo "âœ… Copied Python modules"
fi

# å‰µå»ºå•Ÿå‹•è…³æœ¬
cat > portable-coccinelle/spatch.sh << 'LAUNCHER'
#!/bin/bash
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# è¨­ç½®ç’°å¢ƒè®Šæ•¸
export LD_LIBRARY_PATH="$SCRIPT_DIR/lib:$SCRIPT_DIR/lib/ocaml:$LD_LIBRARY_PATH"
export OCAML_TOPLEVEL_PATH="$SCRIPT_DIR/lib/ocaml"
export PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$SCRIPT_DIR/lib/coccinelle/python:$SCRIPT_DIR/python"

# åŸ·è¡Œ spatch
exec "$SCRIPT_DIR/bin/spatch" "$@"
LAUNCHER

chmod +x portable-coccinelle/spatch.sh
chmod +x portable-coccinelle/bin/spatch

# å‰µå»ºç›´æŽ¥å¯åŸ·è¡Œçš„ spatch
cp portable-coccinelle/spatch.sh portable-coccinelle/spatch

# æ¸¬è©¦å¯æ”œå¼ç‰ˆæœ¬
echo "Testing portable version..."
./portable-coccinelle/spatch.sh --version

# æª¢æŸ¥ä¾è³´
echo "Binary dependencies:"
ldd portable-coccinelle/bin/spatch | head -10

# æ‰“åŒ…
tar -czf "coccinelle-${SUCCESS_VERSION}-portable.tar.gz" portable-coccinelle/

echo "âœ… Package created: coccinelle-${SUCCESS_VERSION}-portable.tar.gz"
echo "Package size: $(du -h coccinelle-${SUCCESS_VERSION}-portable.tar.gz | cut -f1)"
PACKAGESCRIPT

        # å»ºç½® Docker é¡åƒä¸¦é‹è¡Œ
        echo "Building Docker image..."
        docker build -t coccinelle-builder .
        
        echo "Running build in Docker..."
        docker run --name coccinelle-build coccinelle-builder
        
        # å¾žå®¹å™¨ä¸­è¤‡è£½çµæžœ
        echo "Copying build results..."
        docker cp coccinelle-build:/build/coccinelle-*-portable.tar.gz ./
        docker cp coccinelle-build:/build/SUCCESS_VERSION ./
        
        # æª¢æŸ¥çµæžœ
        if [ -f "SUCCESS_VERSION" ]; then
            SUCCESS_VERSION=$(cat SUCCESS_VERSION)
            PACKAGE_FILE="coccinelle-${SUCCESS_VERSION}-portable.tar.gz"
            
            if [ -f "$PACKAGE_FILE" ]; then
                echo "âœ… Build successful!"
                echo "Version: $SUCCESS_VERSION"
                echo "Package: $PACKAGE_FILE"
                echo "Size: $(du -h $PACKAGE_FILE | cut -f1)"
                
                # å‰µå»º GitHub Release
                echo "Creating GitHub Release..."
                
                RELEASE_TAG="coccinelle-${SUCCESS_VERSION}-$(date +%Y%m%d-%H%M%S)"
                RELEASE_NAME="Coccinelle ${SUCCESS_VERSION} (GLIBC 2.23 Compatible)"
                
                cat > payload.json << 'JSONPAYLOAD'
{
  "tag_name": "REPLACE_TAG",
  "target_commitish": "main", 
  "name": "REPLACE_NAME",
  "body": "REPLACE_BODY",
  "draft": false,
  "prerelease": false
}
JSONPAYLOAD
                
                # æ›¿æ›ä½”ä½ç¬¦
                sed -i "s/REPLACE_TAG/$RELEASE_TAG/" payload.json
                sed -i "s/REPLACE_NAME/$RELEASE_NAME/" payload.json
                sed -i "s/REPLACE_BODY/Coccinelle $SUCCESS_VERSION Portable Package/" payload.json
                
                RELEASE_RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}" -X POST \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Content-Type: application/json" \
                  "https://api.github.com/repos/$GITHUB_REPOSITORY/releases" \
                  -d @payload.json)
                
                HTTP_CODE=$(echo "$RELEASE_RESPONSE" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
                RESPONSE_BODY=$(echo "$RELEASE_RESPONSE" | sed 's/HTTP_CODE:[0-9]*$//')
                
                if [ "$HTTP_CODE" = "201" ]; then
                    UPLOAD_URL=$(echo "$RESPONSE_BODY" | grep -o '"upload_url": "[^"]*' | cut -d'"' -f4 | sed 's/{?name,label}//')
                    RELEASE_HTML_URL=$(echo "$RESPONSE_BODY" | grep -o '"html_url": "[^"]*' | cut -d'"' -f4)
                    
                    echo "Uploading package..."
                    UPLOAD_RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}" -X POST \
                      -H "Authorization: token $GITHUB_TOKEN" \
                      -H "Content-Type: application/gzip" \
                      --data-binary "@$PACKAGE_FILE" \
                      "${UPLOAD_URL}?name=$PACKAGE_FILE")
                    
                    UPLOAD_HTTP_CODE=$(echo "$UPLOAD_RESPONSE" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
                    
                    if [ "$UPLOAD_HTTP_CODE" = "201" ]; then
                        echo "========================================="
                        echo "ðŸŽ‰ SUCCESS! Coccinelle $SUCCESS_VERSION"
                        echo "========================================="
                        echo "Release: $RELEASE_HTML_URL"
                        echo "Package: $PACKAGE_FILE"
                        echo "Compatible with: Ubuntu 16.04+ (GLIBC 2.23+)"
                        echo "========================================="
                    else
                        echo "âŒ Upload failed"
                    fi
                else
                    echo "âŒ Release creation failed"
                fi
            else
                echo "âŒ Package file not found"
                exit 1
            fi
        else
            echo "âŒ Build failed - no success version"
            exit 1
        fi
        
        # æ¸…ç†
        docker rm coccinelle-build || true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
